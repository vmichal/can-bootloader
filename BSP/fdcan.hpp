#pragma once

#if defined BOOT_STM32G4
/*
 * Disruptor - eForce SiC Motor controller
 *
 * Written by Vojtech Michal
 *
 * Copyright (c) 2022 eForce FEE Prague Formula
 *
 * This header contains the interface towards FDCAN communication peripherals.
 */

#include <ufsel/units.hpp>
#include <ufsel/assert.hpp>
#include <ufsel/bit_operations.hpp>
#include <array>
#include <optional>
#include <Drivers/stm32g4xx.h>

#include <Bootloader/options.hpp>
#include <can_Bootloader.h>

namespace bsp::can {

	// Data for CAN filter configuration
	// 11 bits standard IDs. They share prefix 0x62_, the three bits are variable (range 0x620-0x627)
	namespace filter {
		constexpr unsigned sharedPrefix = 0x62 << 4;
		constexpr unsigned mustMatch = ufsel::bit::bitmask_of_width(8) << 3;
	}

	struct bus_info_t {
		int bus_index; // Software only, used for indexing into arrays and stuff. Zero-based
		char const * bus_name; // Human readable bus name, used for printing
		candb_bus_t candb_bus; // Enumeration generated by CANdb, used for interaction with CANdb
		std::uintptr_t peripheral_address; // This struct is used in constexpr context, can't use FDCAN_GlobalTypedef* as that involves reinterpret_cast
		Frequency bitrate_nominal;
		Frequency bitrate_data;
		bool fd_frame; // Allow higher DLC and longer frames
		bool bitrate_switching; // Enable higher bitrate for data section of CAN frames

		[[nodiscard]]
		FDCAN_GlobalTypeDef * get_peripheral() const {
			return (FDCAN_GlobalTypeDef*) peripheral_address;
		}
	};

	///////////////////////////////////////////////
	// CUSTOMIZATION POINT
	///////////////////////////////////////////////

    constexpr std::array bus_info = {
		// Car CANs, both FD capable.
#if CAN1_used
	    bus_info_t {.bus_index = 0, .bus_name = "CAN1", .candb_bus = bus_CAN1, .peripheral_address = CAN1_PERIPHERAL, .bitrate_nominal = CAN1_BITRATE, .bitrate_data = 1'000_kHz, .fd_frame = false, .bitrate_switching = false},
#endif
#if CAN2_used
	    bus_info_t {.bus_index = 1, .bus_name = "CAN2", .candb_bus = bus_CAN2, .peripheral_address = CAN2_PERIPHERAL, .bitrate_nominal = CAN2_BITRATE, .bitrate_data = 1'000_kHz, .fd_frame = false, .bitrate_switching = false},
#endif
	};

	constexpr auto kernel_clock_frequency = boot::SYSCLK;

	///////////////////////////////////////////////
	// END OF CUSTOMIZATION POINT
	///////////////////////////////////////////////

	constexpr std::size_t num_used_buses = std::size(bus_info);

	constexpr std::size_t max_canfd_data_length = 64;

	constexpr std::array data_lengths {
		0,1,2,3,
		4,5,6,7,
		8,12,16,20,
		24,32,48,64};
	static_assert(std::size(data_lengths) == 16);
	static_assert(data_lengths.back() == max_canfd_data_length);

	//////////////////////////////
	// Conversions between the Data Length Code (sent as part of the CAN frame) and number of Data bytes
	//////////////////////////////

	constexpr int DLC_to_length(int const DLC) {
		return data_lengths[DLC];
	}

	constexpr std::optional<int> length_to_DLC(int const length) {
		auto const iter = std::ranges::find(data_lengths, length);
		if (iter == data_lengths.end())
			return std::nullopt; // No DLC matches this data length
		return std::distance(data_lengths.begin(), iter);
	}

	namespace message_RAM {
		constexpr std::size_t word_count = 212;
		constexpr InformationSize size = InformationSize::fromBytes(word_count * 4);
		static_assert(size.toBytes() == 0x350);

		namespace RX_FIFO {
			struct element {
				std::uint32_t R0;
				std::uint32_t R1;
				// Message data are stored such that
				// data[i] = data_byte[4*i] | data_byte[4*i + 1] << 8 | data_byte[4*i + 2] << 16 | data_byte[4*i + 3] << 24
				// i.e. the LSB is the LSB of stored word
				std::uint32_t data[max_canfd_data_length / sizeof(std::uint32_t)];
			};

			///////////////////////////////////////////////////////////////
			// Definition of bitmasks for interaction with RX FIFO elements
			///////////////////////////////////////////////////////////////

			constexpr std::uint32_t R0_ESI_Msk = ufsel::bit::bit(31);
			constexpr std::uint32_t R0_XTD_Msk = ufsel::bit::bit(30);
			constexpr std::uint32_t R0_RTR_Msk = ufsel::bit::bit(29);
			constexpr std::uint32_t R0_ID_Msk_EXT = ufsel::bit::bitmask_between(28, 0);
			constexpr std::uint32_t R0_ID_Msk_STD = ufsel::bit::bitmask_between(28, 18);

			constexpr std::uint32_t R1_ANMF_Msk = ufsel::bit::bit(31);
			constexpr std::uint32_t R1_FIDX_Msk = ufsel::bit::bitmask_between(30, 24);
			// R1 bits 23:22 reserved
			constexpr std::uint32_t R1_FDF_Msk = ufsel::bit::bit(21);
			constexpr std::uint32_t R1_BRS_Msk = ufsel::bit::bit(20);
			constexpr std::uint32_t R1_DLC_Msk = ufsel::bit::bitmask_between(19, 16);
			constexpr std::uint32_t R1_RXTS_Msk = ufsel::bit::bitmask_between(15, 0);
		}

		namespace TX_Buffer {
			struct element {
				// Bits T0_ESI, T1_FDF and T1_BRS are unused in non-FD operation
				std::uint32_t T0;
				std::uint32_t T1;
				// Message data are stored the same way as in RX FIFO elements. Refer to their comments
				std::uint32_t data[max_canfd_data_length / sizeof(std::uint32_t)];
			};

			/////////////////////////////////////////////////////////////////
			// Definition of bitmasks for interaction with TX Buffer elements
			/////////////////////////////////////////////////////////////////

			constexpr std::uint32_t T0_ESI_Msk = ufsel::bit::bit(31);
			constexpr std::uint32_t T0_XTD_Msk = ufsel::bit::bit(30);
			constexpr std::uint32_t T0_RTR_Msk = ufsel::bit::bit(29);
			constexpr std::uint32_t T0_ID_Msk_EXT = ufsel::bit::bitmask_between(28, 0);
			constexpr std::uint32_t T0_ID_Msk_STD = ufsel::bit::bitmask_between(28, 18);

			constexpr std::uint32_t T1_MM_Msk = ufsel::bit::bitmask_between(31, 24);
			constexpr std::uint32_t T1_EFC_Msk = ufsel::bit::bit(23);
			// T1 bit 22 reserved
			constexpr std::uint32_t T1_FDF_Msk = ufsel::bit::bit(21);
			constexpr std::uint32_t T1_BRS_Msk = ufsel::bit::bit(20);
			constexpr std::uint32_t T1_DLC_Msk = ufsel::bit::bitmask_between(19, 16);
			// T1 bits 15:0 reserved
		}

		namespace TX_event_FIFO {
			struct element {
				std::uint32_t E0;
				std::uint32_t E1;
			};

			/////////////////////////////////////////////////////////////////////
			// Definition of bitmasks for interaction with TX event FIFO elements
			/////////////////////////////////////////////////////////////////////

			constexpr std::uint32_t E0_ESI_Msk = ufsel::bit::bit(31);
			constexpr std::uint32_t E0_XTD_Msk = ufsel::bit::bit(30);
			constexpr std::uint32_t E0_RTR_Msk = ufsel::bit::bit(29);
			constexpr std::uint32_t E0_ID_Msk_EXT = ufsel::bit::bitmask_between(28, 0);
			constexpr std::uint32_t E0_ID_Msk_STD = ufsel::bit::bitmask_between(28, 18);

			constexpr std::uint32_t E1_MM_Msk = ufsel::bit::bitmask_between(31, 24);
			constexpr std::uint32_t E1_ET_Msk = ufsel::bit::bitmask_between(23, 22);
			constexpr std::uint32_t E1_EDL_Msk = ufsel::bit::bit(21);
			constexpr std::uint32_t E1_BRS_Msk = ufsel::bit::bit(20);
			constexpr std::uint32_t E1_DLC_Msk = ufsel::bit::bitmask_between(19, 16);
			constexpr std::uint32_t E1_TXTS_Msk = ufsel::bit::bitmask_between(15, 0);
		}

		namespace STD_Filter {
			struct element {
				std::uint32_t S0;
			};

			//////////////////////////////////////////////////////////////////////
			// Definition of bitmasks for interaction with Standard Filter element
			//////////////////////////////////////////////////////////////////////

			enum class SFT {
				Range = 0b00,
				DualID = 0b01,
				FilterWithMask = 0b10,
				Deactivated = 0b11,
			};

			enum class SFEC {
				Disable = 0b000,
				OnMatchStoreTo0 = 0b001,
				OnMatchStoreTo1 = 0b010,
				OnMatchReject = 0b011,
				OnMatchSetPriority = 0b100,
				PriorityOnMatchStoreTo0 = 0b101,
				PriorityOnMatchStoreTo1 = 0b110
			};

			constexpr std::uint32_t S0_SFT_Msk = ufsel::bit::bitmask_between(31, 30);
			constexpr std::uint32_t S0_SFEC_Msk = ufsel::bit::bitmask_between(29, 27);
			constexpr std::uint32_t S0_SFID1_Msk = ufsel::bit::bitmask_between(26, 16);
			constexpr std::uint32_t S0_SFID2_Msk = ufsel::bit::bitmask_between(10, 0);
		}

		namespace EXT_Filter {
			struct element {
				std::uint32_t F0;
				std::uint32_t F1;
			};

			//////////////////////////////////////////////////////////////////////
			// Definition of bitmasks for interaction with Extended Filter element
			//////////////////////////////////////////////////////////////////////

			enum class EFT {
				RangeWithXidam = 0b00,
				DualID = 0b01,
				FilterWithMask = 0b10,
				RangeNoXidam = 0b1,
			};

			enum class EFEC {
				Disable = 0b000,
				OnMatchStoreTo0 = 0b001,
				OnMatchStoreTo1 = 0b010,
				OnMatchReject = 0b011,
				OnMatchSetPriority = 0b100,
				PriorityOnMatchStoreTo0 = 0b101,
				PriorityOnMatchStoreTo1 = 0b110
			};

			constexpr std::uint32_t F0_EFEC_Msk = ufsel::bit::bitmask_between(31, 29);
			constexpr std::uint32_t F0_EFID1_Msk = ufsel::bit::bitmask_between(28, 0);
			constexpr std::uint32_t F1_EFTI_Msk = ufsel::bit::bitmask_between(31, 30);
			// F1 bit 29 not used
			constexpr std::uint32_t F1_EFID2_Msk = ufsel::bit::bitmask_between(28, 0);
		}

		static_assert(sizeof(RX_FIFO::element) == 72);
		static_assert(sizeof(TX_Buffer::element) == 72);
		static_assert(sizeof(TX_event_FIFO::element) == 8);
		static_assert(sizeof(EXT_Filter::element) == 8);
		static_assert(sizeof(STD_Filter::element) == 4);
	}

	struct MessageRAM_TypeDef {
		message_RAM::STD_Filter::element std_filter[28];
		message_RAM::EXT_Filter::element ext_filter[8];
		message_RAM::RX_FIFO::element rx_fifo0[3];
		message_RAM::RX_FIFO::element rx_fifo1[3];
		message_RAM::TX_event_FIFO::element tx_event_fifo[3];
		message_RAM::TX_Buffer::element tx_buffers[3];
	};


	// Sanity checks to make sure the memory mapping of Message RAM matches the hardware
	static_assert(offsetof(MessageRAM_TypeDef, std_filter) == 0);
	static_assert(offsetof(MessageRAM_TypeDef, ext_filter) == 0x70);
	static_assert(offsetof(MessageRAM_TypeDef, rx_fifo0) == 0xB0);
	static_assert(offsetof(MessageRAM_TypeDef, rx_fifo1) == 0x188);
	static_assert(offsetof(MessageRAM_TypeDef, tx_event_fifo) == 0x260);
	static_assert(offsetof(MessageRAM_TypeDef, tx_buffers) == 0x278);
	static_assert(sizeof(MessageRAM_TypeDef) == message_RAM::size.toBytes());



	namespace message_RAM {
		// Periph num is 0 for FDCAN1, 1 for FDCAN2 and 2 for FDCAN3
		constexpr std::uintptr_t address_for_peripheral(int const periph_num) {
			return SRAMCAN_BASE + periph_num * message_RAM::size.toBytes();
		}

		// Examples of Message RAM addresses given in the reference manual
		static_assert(address_for_peripheral(0) == SRAMCAN_BASE);
		static_assert(address_for_peripheral(1) == SRAMCAN_BASE + 0x350);
	}

	inline MessageRAM_TypeDef * get_message_ram_for_periph(FDCAN_GlobalTypeDef * const can) {
		int const periph_index = [can]() {
			switch (reinterpret_cast<std::uintptr_t>(can)) {
				case FDCAN1_BASE: return 0;
				case FDCAN2_BASE: return 1;
				case FDCAN3_BASE: return 2;
			}
			assert_unreachable();
		}();
		return reinterpret_cast<MessageRAM_TypeDef*>(message_RAM::address_for_peripheral(periph_index));
	}

	// find_ functions come in two flavours:
	// 1) The template version guarantees compile time evaluation and costs pretty much nothing
	// 2) The non-template version is viable for dynamic argument resolution but may involve some runtime calculations
	template<candb_bus_t bus>
	constexpr bus_info_t const& find_bus_info_by_bus() {
		constexpr auto iter = std::ranges::find(bus_info, bus, &bus_info_t::candb_bus);
		static_assert(iter != std::end(bus_info));
		return *iter;
	}

	inline bus_info_t const& find_bus_info_by_bus(candb_bus_t bus) {
		auto const iter = std::ranges::find(bus_info, bus, &bus_info_t::candb_bus);
		assert(iter != std::end(bus_info));
		return *iter;
	}

	template<std::uintptr_t periph_base>
	constexpr bus_info_t const& find_bus_info_by_peripheral() {
		constexpr auto iter = std::ranges::find(bus_info, periph_base, &bus_info_t::peripheral_address);
		static_assert(iter != std::end(bus_info));
		return *iter;
	}

	inline bus_info_t const& find_bus_info_by_peripheral(std::uintptr_t periph_base) {
		auto const iter = std::ranges::find(bus_info, periph_base, &bus_info_t::peripheral_address);
		assert(iter != std::end(bus_info));
		return *iter;
	}

	template<std::uintptr_t periph_base>
	constexpr bool peripheral_is_used() {
		constexpr auto iter = std::ranges::find(bus_info, periph_base, &bus_info_t::peripheral_address);
		return iter != std::end(bus_info);
	}

	[[nodiscard]]
	inline FDCAN_GlobalTypeDef * peripheral_by_candb_bus(candb_bus_t const bus) {
		return find_bus_info_by_bus(bus).get_peripheral();
	}

	struct MessageData {
		std::uint32_t id, length;
		// Message data stored using little endian. First word has first message byte as its LSB
		std::array<std::uint32_t, max_canfd_data_length / sizeof(std::uint32_t)> data;
	};

	void initialize(); //Fully initializes both CAN peripherals using configured clock frequencies.

	void write_message_for_transmission(bus_info_t const& bus, MessageData const& msg);

	//Returns true iff the given peripheral has at least one mailbox empty.
	[[nodiscard]]
	inline bool has_empty_mailbox(FDCAN_GlobalTypeDef const* const can) {
		return not ufsel::bit::get(can->TXFQS, FDCAN_TXFQS_TFQF);
	}

	[[nodiscard]]
	inline bool has_empty_mailbox(candb_bus_t bus) {
		return has_empty_mailbox(peripheral_by_candb_bus(bus));
	}

	enum class LEC {
		NoError = 0b000,
		StuffError = 0b001,
		FormError = 0b010,
		AckError = 0b011,
		Bit1Error = 0b100,
		Bit0Error = 0b101,
		CRCError = 0b110,
		NoChange = 0b111
	};
	[[nodiscard]]
	inline LEC get_last_error_code(FDCAN_GlobalTypeDef * const can) {
		constexpr auto slice = ufsel::bit::slice::for_mask(FDCAN_PSR_LEC_Msk);
		return ufsel::bit::sliceable_value{ can->PSR }.decode_as<LEC>()[slice];
	};

	[[nodiscard]]
	inline bool has_ack_error(FDCAN_GlobalTypeDef * const can) {
		return get_last_error_code(can) == LEC::AckError;
	};

} // end namespace bsp::can

#endif
