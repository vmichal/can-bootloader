#pragma once

/* Define to prevent recursive inclusion -------------------------------------*/
#if !defined BOOT_STM32G4


#include <Bootloader/options.hpp>
#include <ufsel/units.hpp>
#include <ufsel/assert.hpp>
#include <ufsel/bit.hpp>

namespace bsp::can {

	struct bus_info_t {
		int bus_index; // Software only, used for indexing into arrays and stuff. Zero-based
		char const * bus_name; // Human readable bus name, used for printing
		candb_bus_t candb_bus; // Enumeration generated by CANdb, used for interaction with CANdb
		std::uintptr_t peripheral_address; // This struct is used in constexpr context, can't use FDCAN_GlobalTypedef* as that involves reinterpret_cast
		Frequency bitrate;

		[[nodiscard]]
		CAN_TypeDef * get_peripheral() const {
			return (CAN_TypeDef*) peripheral_address;
		}
	};

    constexpr std::array bus_info = {
		// Car CANs
#if CAN1_used
	    bus_info_t {.bus_index = 0, .bus_name = "CAN1", .candb_bus = bus_CAN1, .peripheral_address = CAN1_PERIPHERAL, .bitrate = CAN1_BITRATE},
#endif
#if CAN2_used
	    bus_info_t {.bus_index = 1, .bus_name = "CAN2", .candb_bus = bus_CAN2, .peripheral_address = CAN2_PERIPHERAL, .bitrate = CAN2_BITRATE},
#endif
	};

	inline bus_info_t const& find_bus_info_by_bus(candb_bus_t bus) {
		auto const iter = std::ranges::find(bus_info, bus, &bus_info_t::candb_bus);
		assert(iter != std::end(bus_info));
		return *iter;
	}

	inline bus_info_t const& find_bus_info_by_peripheral(std::uintptr_t periph_base) {
		auto const iter = std::ranges::find(bus_info, periph_base, &bus_info_t::peripheral_address);
		assert(iter != std::end(bus_info));
		return *iter;
	}

	constexpr std::size_t num_used_buses = std::size(bus_info);

	struct MessageData {
		std::uint32_t id, length;
		// Message data stored using little endian. First word has first message byte as its LSB
		std::array<std::uint32_t, 2> data;
	};

	void write_message_for_transmission(bus_info_t const& bus, MessageData const& msg);

	// Data for CAN filter configuration
	// 11 bits standard IDs. They share prefix 0x62_, the three bits are variable (range 0x620-0x627)
	namespace filter {
		constexpr unsigned sharedPrefix = 0x62 << 4;
		constexpr unsigned mustMatch = ufsel::bit::bitmask_of_width(8) << 3;
	}

	//Returns true iff the given peripheral has at least one mailbox empty.
	[[nodiscard]]
	inline bool has_empty_mailbox(CAN_TypeDef const* const can) {
		return ufsel::bit::any_set(can->TSR, CAN_TSR_TME);
	}

	void initialize();



} // end namespace bsp::can

#endif /*__CAN_H */

/* END OF FILE */
